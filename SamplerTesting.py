
import numpy as np
import matplotlib.pyplot as plt
from qiskit.quantum_info import SparsePauliOp
from matplotlib import colors
from qiskit.circuit import QuantumCircuit
from qiskit_qulacs.qulacs_estimator import QulacsEstimator
from helpers import *
from Sampler import Sampler
from qiskit.quantum_info import SparsePauliOp, Pauli, Statevector, PauliList
from tqdm import tqdm

def analyse_output_bitstrings(sampler, repeats = 100, title = "Transition Matrix", plot_grid = False, plot_cumulative = False):
    """
    Analyzes the output bitstrings generated by a sampler and computes various metrics 
    related to transition probabilities, BD transitions, and forbidden/self transitions. 
    Optionally, it visualizes the transition matrix and cumulative probability distributions.
    Parameters:
    -----------
    sampler : object
        The sampler object that generates proposals and contains relevant parameters 
        such as `n` (number of nodes) and `q` (number of bits in the bitstring).
    repeats : int, optional
        The number of times to repeat the sampling process for each configuration. 
        Default is 100.
    title : str, optional
        The title for the transition matrix plot. Default is "Transition Matrix".
    plot_grid : bool, optional
        If True, displays the transition matrix plot. If False, the plot is closed. 
        Default is False.
    plot_cumulative : bool, optional
        If True, displays the cumulative probability histogram. If False, the plot is closed. 
        Default is False.
    Returns:
    --------
    weighted_BD_transitions_ignoring_self_transitions : numpy.ndarray
        A flattened array of weighted BD transitions, excluding self-transitions, 
        used for cumulative probability analysis.
    Notes:
    ------
    - The function computes the transition matrix, BD action differences, and 
        forbidden/self transition frequencies.
    - The function supports visualization of the transition matrix and cumulative 
        probability distributions.
    - Forbidden transitions are transitions to configurations that are not valid 
        causal matrices.
    - Self-transitions are transitions where the initial and proposed configurations 
        are the same.
    """
    
    
    _, unique_causal_matrix = get_unique_matrices(sampler.n)
    
    
    
    mats = [np.frombuffer(mat, dtype=np.int32).reshape( sampler.n,  sampler.n) for mat in  unique_causal_matrix]
    
    print(" ")
    print("Number of unique causal matrices: ", len(mats))
    labels = ["".join(str(i) for i in mat[np.triu_indices( sampler.n, 1)]) for mat in mats]
    costs = np.zeros((2** sampler.q,2** sampler.q))
    BD_action = np.zeros(2** sampler.q)
    first_loop = True
    #for r in tqdm(range(repeats), desc="Repeats"):
    for s_pos, s in tqdm(enumerate(labels)):
        s_prime_list =  sampler.proposal(s, multiple = repeats)
        
        s_int = int(s, 2)
        
        for s_prime in s_prime_list:
            s_prime_int = int(s_prime, 2)
            costs[s_int, s_prime_int] += 1

        if first_loop:
            BD_action[s_int] =  calculate_action(mats[s_pos])
    first_loop = False
    
    
    
    BD_sorted_args = np.argsort(BD_action)
    sorted_BD = BD_action[BD_sorted_args]
    costs = costs[BD_sorted_args,:]
    costs = costs[:,BD_sorted_args]

    
    #reorder and normalise
    _costs = np.flipud(costs)/repeats
    
    cmap = colors.LinearSegmentedColormap.from_list('red_white', ['white', 'red'], N=256)
    
    
    non_zero_bd_index = np.where(sorted_BD != 0)[0][0]
    plt.xticks([])
    plt.yticks([])
    plt.ylim(non_zero_bd_index, 2** sampler.q)
    
    plt.imshow(_costs, extent=[0, 2** sampler.q, 0, 2** sampler.q], cmap=cmap, interpolation='nearest', norm=colors.LogNorm())
        
    
    
    plt.colorbar(label='Transition Counts', norm=colors.LogNorm())
    plt.xlabel('Proposed Configuration (s\')')
    plt.ylabel('Initial Configuration (s)')
    plt.title(title)
    
    
    s_int_list = [int(s, 2) for s in labels]
    all_ints = np.arange(0, 2** sampler.q)
    

    all_ints = all_ints[BD_sorted_args]
    
    plt.plot([non_zero_bd_index, 2** sampler.q], [non_zero_bd_index,non_zero_bd_index] ,color='blue', linestyle='--', label='Non-zero BD')
    plt.plot([non_zero_bd_index,non_zero_bd_index], [non_zero_bd_index, 2**sampler.q] ,color='blue', linestyle='--', label='Non-zero BD')


    
    forbidden_count = 0
    for s_pos, s_int in enumerate(all_ints):
        if s_int not in s_int_list:
            for pos_i, i in enumerate(all_ints):
                if costs[pos_i, s_pos] > 0:
                    forbidden_count += costs[pos_i, s_pos]

            
    print(" ")
    print(" --------------------- ")
    print(title)
    BD_transitions = np.zeros((2** sampler.q,2** sampler.q))
    for i in range(2** sampler.q):
        for j in range(2** sampler.q):
            BD_transitions[i,j] = np.abs(sorted_BD[i] - sorted_BD[j])
    
    total_bd_transition_cost = np.sum((BD_transitions[non_zero_bd_index:,non_zero_bd_index:] * costs[non_zero_bd_index:,non_zero_bd_index:]))
    
    total_transitions = np.sum(costs)
    
    self_transitions = np.sum(np.diag(costs))
    
    print(" ")
    print("Average BD transition cost: ", total_bd_transition_cost/(total_transitions-forbidden_count-self_transitions))
    print(" ")
    print("Frequency of self transitions: ", self_transitions / total_transitions)
    print("Frequency of forbidden transitions: ", forbidden_count / total_transitions)
    
    if plot_grid:
        plt.show()
    else:
        plt.close()
    fig, ax = plt.subplots()
    weighted_BD_transitions = np.repeat(BD_transitions[non_zero_bd_index:,non_zero_bd_index:].flatten(), costs[non_zero_bd_index:,non_zero_bd_index:].flatten().astype(int)).flatten()
    costs_no_self = np.copy(costs)
    np.fill_diagonal(costs_no_self, 0)
    weighted_BD_transitions_ignoring_self_transitions = np.repeat(BD_transitions[non_zero_bd_index:,non_zero_bd_index:].flatten(), costs_no_self[non_zero_bd_index:,non_zero_bd_index:].flatten().astype(int)).flatten()
    ax.hist(weighted_BD_transitions, bins=50, density=True, cumulative=True, histtype='step', label='Cumulative Probability')
    ax.hist(weighted_BD_transitions_ignoring_self_transitions, bins=50, density=True, cumulative=True, histtype='step', label='Cumulative Probability (no self transitions)')
    ax.set_xlabel('BD Transitions')
    ax.set_ylabel('Cumulative Probability')
    ax.set_title('Cumulative Probability of BD Transitions')
    ax.legend()
    
    if plot_cumulative:
        plt.show()
    else:
        plt.close()
    
    
    print(" --------------------- ")
    print(" ")
    
    return weighted_BD_transitions_ignoring_self_transitions

    
    
    
    



cardinality = 4

transitions = []
titles = []

# Gammas order is  TC, BD, Mixing
title = "Mixing only"
titles.append(title)
Qsamp = Sampler(cardinality, method="quantum", qargs = {"gammas":[0,0,1], "t":5})
transitions.append(analyse_output_bitstrings(Qsamp, repeats = 10000, title = title, plot_grid = True, plot_cumulative = False))


title = "Mixing and BD"
titles.append(title)
Qsamp = Sampler(cardinality, method="quantum", qargs = {"gammas":[0, 0.8, 0.2], "t":5})
transitions.append(analyse_output_bitstrings(Qsamp, repeats = 10000, title = title, plot_grid = True, plot_cumulative = False))

title = "Mixing and TC"
titles.append(title)
Qsamp = Sampler(cardinality, method="quantum", qargs = {"gammas":[0.95, 0, 0.05], "t":5})
transitions.append(analyse_output_bitstrings(Qsamp, repeats = 10000, title = title, plot_grid = True, plot_cumulative = False))

title = "Mixing, TC and BD"
titles.append(title)
Qsamp = Sampler(cardinality, method="quantum", qargs = {"gammas":[0.95, 0.01, 0.04], "t":5})
transitions.append(analyse_output_bitstrings(Qsamp, repeats = 10000, title = title, plot_grid = True, plot_cumulative = False))



